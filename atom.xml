<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haijiao&#39;s Notes</title>
  
  <subtitle>生活杂谈|技术随想</subtitle>
  <link href="http://haijiaogao.github.io/blogs/atom.xml" rel="self"/>
  
  <link href="http://haijiaogao.github.io/blogs/"/>
  <updated>2021-03-03T07:04:04.004Z</updated>
  <id>http://haijiaogao.github.io/blogs/</id>
  
  <author>
    <name>Gaohaijiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Knowledge&amp;Interview</title>
    <link href="http://haijiaogao.github.io/blogs/2021/02/23/Android-Knowledge-Interview/"/>
    <id>http://haijiaogao.github.io/blogs/2021/02/23/Android-Knowledge-Interview/</id>
    <published>2021-02-23T11:14:11.787Z</published>
    <updated>2021-03-03T07:04:04.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-基础知识复习"><a href="#Android-基础知识复习" class="headerlink" title="Android 基础知识复习"></a>Android 基础知识复习</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><p><img src="https://camo.githubusercontent.com/908f0c391fd50377aebbb3c0fd1a0c4419007c0eecb7651a1908be8e273a46ab/687474703a2f2f6769747975616e2e636f6d2f696d616765732f6c6966656379636c652f61637469766974792e706e67" alt="image"></p><p>Activity A 启动另一个Activity B，回调如下:<br>Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop()；如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop；</p><h3 id="Activity的启动模式和Android的任务栈分析"><a href="#Activity的启动模式和Android的任务栈分析" class="headerlink" title="Activity的启动模式和Android的任务栈分析"></a>Activity的启动模式和Android的任务栈分析</h3><h4 id="四种启动模式：Standard，SingleTop，SingleTask-SingleInstance"><a href="#四种启动模式：Standard，SingleTop，SingleTask-SingleInstance" class="headerlink" title="四种启动模式：Standard，SingleTop，SingleTask,SingleInstance"></a>四种启动模式：Standard，SingleTop，SingleTask,SingleInstance</h4><ol><li>Standard: 默认启动模式当目标Activity在AndroidManifest中为Standard类型时，不管当前的任务栈中是否已经存在该Activity的实例，都重新生成一个Activity的实例，并推入任务栈栈顶。</li><li>SingleTop: 当目标Activity被声明为SingleTop时，如目标不存在，则新建一个activity放在栈顶；如果目标已经存在，并且非处于任务栈顶，则重新生成一个目标Activity放在栈顶；如果目标已经存在，并处于栈顶，则调用该Activity的onNewIntent方法。</li><li>SingleTask: 当目标Activity被声明为SingleTask的时候，如果说目标不存在，则新建一个Activity放在栈顶，并且新建一个目标Activity放在栈中；如果目标存在于当前栈中，则将当前栈中位于目标之上的Activity全部都出栈并销毁（onDestory方法会调用），并调用目标Activity的onNewIntent方法。</li><li>SingleInstance： 当目标Activity被声明为SingleInstance的时候，如果说目标不存在，则新建一个Task，并把新建的目标Activity压入栈中；singleInstance的Activity始终单独使用一个任务栈；如果目标存在，则调用该Activity的onNewIntent方法。<br>注意：<br>因为 singleInstance 的属性是禁止与其他 Activities 共享任务栈，所以启动模式为 SingleInstance 的 Activity 启动其他 Activity 时会默认带有 FLAG_ACTIVITY_NEW_TASK 属性。所以从一个launchMode为singleInstance的activity中新启动一个启动模式为Standard的 Activity F 后， Activity F会被推到SingleInstance之前的那个标准任务栈的栈顶。</li></ol><h4 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h4><p>什么是affinity？<br>　　affinity是指Activity的归属，Activity与Task的吸附关系，也就是该Activity属于哪个Task。一般情况下在同一个应用中，启动的Activity都在同一个Task中，它们在该Task中度过自己的生命。每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于应用的包名。我们可以通过在元素中增加taskAffinity属性来为某一个Activity指定单独的affinity。这个属性的值是一个字符串，可以指定为任意字符串，但是必须至少包含一个”.”，否则会报错。</p><p>affinity在什么场合应用呢？<br>1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合使用）<br>　　allowTaskReparenting用来标记Activity能否从启动的Task移动到taskAffinity指定的Task，当把Activity的allowTaskReparenting属性设置成true时，Activity就拥有了一个转移所在Task的能力。具体点来说，就是一个Activity现在是处于某个Task当中的，但是它与另外一个Task具有相同的affinity值，那么当另外这个任务切换到前台的时候，该Activity就可以转移到现在的这个任务当中。allowTaskReparenting默认是继承至application中的allowTaskReparenting=false，如果为true，则表示可以更换；false表示不可以。<br>　　举一个形象点的例子，比如有一个天气预报程序，它有一个用于显示天气信息的Activity，allowTaskReparenting属性设置成true，这个Activity和天气预报程序的所有其它Activity具体相同的affinity值。这个时候，你自己的应用程序通过Intent去启动了这个用于显示天气信息的Activity，那么此时这个Activity应该是和你的应用程序是在同一个任务当中的。但是当把天气预报程序切换到前台的时候，这个Activity会被转移到天气预报程序的任务当中，并显示出来。如果将你自己的应用切换到前台，发现你自己应用Task里的那个Activity消失了。</p><p>2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task。<br>　　当调用startActivity()方法来启动一个Activity时，默认是将它放入到当前的任务当中。但是，如果在Intent中加入了FLAG_ACTIVITY_NEW_TASK flag的话，情况就会变的复杂起来。首先，系统会去检查这个Activity的affinity是否与当前Task的affinity相同。如果相同的话就会把它放入到当前Task当中，如果不同则会先去检查是否已经有一个名字与该Activity的affinity相同的Task,如果有，这个Task将被调到前台，同时这个Activity将显示在这个Task的顶端；如果没有的话，系统将会尝试为这个Activity创建一个新的Task。需要注意的是，如果一个Activity在manifest文件中声明的启动模式是”singleTask”，那么他被启动的时候，行为模式会和前面提到的指定FLAG_ACTIVITY_NEW_TASK一样。<br>　　那么，有了上面的知识，我们应该可以实现开头提到的功能了。</p><h4 id="IntentFlags"><a href="#IntentFlags" class="headerlink" title="IntentFlags"></a>IntentFlags</h4><p> FLAG_ACTIVITY_BROUGHT_TO_FRONT</p><p>        比方说我现在有Ａ，在Ａ中启动Ｂ，在Ａ中Intent中加上这个标记。此时B就是以FLAG_ACTIVITY_BROUGHT_TO_FRONT 这个启动的，在B中再启动C，D（正常启动C，D），如果这个时候在D中再启动B，这个时候最后的栈的情况是 A,C,D,B。</p><p>FLAG_ACTIVITY_REORDER_TO_FRONT</p><p>        如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。 例如，假设一个Task由四个Activity组成：A，B，C，D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A，C，D，B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被覆盖。</p><p>FLAG_ACTIVITY_CLEAR_TASK</p><p>        如果在调用startActivity时传递这个标记，该task栈中的其他activity会先被清空，然后该activity在该task中启动，也就是说，这个新启动的activity变为了这个空task的根activity。所有老的activity都结束掉。该标志必须和FLAG_ACTIVITY_NEW_TASK一起使用。</p><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>        如果该activity已经在task中存在，并且设置了该task，系统不会启动新的 Activity 实例，会将task栈里该Activity之上的所有Activity一律结束掉，然后将Intent发给这个已存在的Activity。Activity收到 Intent之后，或者在onNewIntent()里做下一步的处理，或者自行结束然后重新创建。如 Activity 在 AndroidMainifest.xml 里将启动模式设置成默认standard模式，且 Intent 里也没有设置 FLAG_ACTIVITY_SINGLE_TOP，那么Activity将会结束并且重启；否则则会传递到onNewIntent方法。</p><p>已经启动了四个Activity：A，B，C和D。在D Activity里，我们要跳到B Activity，同时希望C finish掉，可以在startActivity(intent)里的intent里添加flags标记，这样启动B Activity，就会把D，C都finished掉，如果你的B Activity的启动模式是默认的（multiple） ，则B Activity会finished掉，再启动一个新的Activity B。  如果不想重新再创建一个新的B Activity，则可在启动Intent添加flag FLAG_ACTIVITY_SINGLE_TOP。</p><p>        可以利用此特性来退出程序，假设A为程序入口，将A的Manifest.xml配置成android:launchMode=”singleTop”，通过此flag来启动A，同时在A的onNewIntent中判断来结束自己，可到退出的效果。FLAG_ACTIVITY_CLEAR_TOP 还可以和 FLAG_ACTIVITY_NEW_TASK 配合使用，用来启动一个task栈的根activity，他将会把该栈清空为根状态，比如从notification manager启动activity。</p><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>        设置完之后，新的activity将不会添加到当前activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。他等同于在XML中指定Activity的属性android:excludeFromRecents=”true”</p><p>FLAG_ACTIVITY_FORWARD_RESULT</p><p>        如果A需要onActivityResult中获取返回结果，startActivityForResult B，而B只是过渡页，启动C之后就finish掉了，需要在 C 中setResult返回给A就可以用到这个标志。</p><p>A -&gt; B -&gt; XXXXX(无论多少个过渡页) 设置 FLAG_ACTIVITY_FORWARD_RESULT 来启动 C ，之后该XXX过渡页finish - &gt; C ，那么C的结果返回给A。</p><p>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</p><p>        如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。例如A启动B的时候，给B设置了FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY，那么：</p><p>A -&gt; B -&gt; C ，启动C 就算 B没有自行finish ，也会变为 AC</p><p>FLAG_ACTIVITY_MULTIPLE_TASK</p><p>        这个标识用来创建一个新的task栈，并且在里面启动新的activity（所有情况，不管系统中存在不存在该activity实例），经常和FLAG_ACTIVITY_NEW_DOCUMENT或者FLAG_ACTIVITY_NEW_TASK一起使用。这上面两种使用场景下，如果没有带上FLAG_ACTIVITY_MULTIPLE_TASK标识，他们都会使系统搜索存在的task栈，去寻找匹配intent的一个activity，如果没有找到就会去新建一个task栈；但是当和FLAG_ACTIVITY_MULTIPLE_TASK一起使用的时候，这两种场景都会跳过搜索这步操作无条件的创建一个新的task。和FLAG_ACTIVITY_NEW_TASK一起使用需要注意，尽量不要使用该组合除非你完成了自己的顶部应用启动器，他们的组合使用会禁用已经存在的task栈回到前台的功能。</p><p>FLAG_ACTIVITY_NEW_DOCUMENT</p><p>        api 21之后加入的一个标识，用来在intent启动的activity的task栈中打开一个document，和documentLaunchMode效果相等，有着不同的documents的activity的多个实例，将会出现在最近的task列表中。</p><p>documentLaunchMode可以设置4个值</p><p>intoExisting： activity 会为该document请求一个已经存在的task，这与设置FLAG_ACTIVITY_NEW_DOCUMENT且不设置FLAG_ACTIVITY_MULTIPLE_TASK 有相同的效果。</p><p>always： activity 会为该document创建一个新的task，即使该document已经被打开了，这与设置 FLAG_ACTIVITY_NEW_DOCUMENT且设置 FLAG_ACTIVITY_MULTIPLE_TASK 有相同的效果。</p><p>none：activity 不会为 document 创建新的task，该app被设置为 single task 的模式，它会重新调用用户唤醒的所有activity中的最近的一个。</p><p>never：activity 不会为document创建一个新的task，设置这个值复写了 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标签。如果其中一个标签被设置，并且overview screen 显示该app为 single task 模式。则该activity会重新调用用户最近唤醒的activity。</p><p>注意： none 或 nerver 使用时，activity必须设置为 launchMode=”standard” ，如果该属性没有设置，documentLaunchMode=”none” 属性就会被使用。有</p><p>FLAG_ACTIVITY_RETAIN_IN_RECENTS</p><p>        api21加入。默认情况下通过FLAG_ACTIVITY_NEW_DOCUMENT启动的activity在关闭之后，task中的记录会相对应的删除。如果为了能够重新启动这个activity你想保留它，就可以使用者个flag，最近的记录将会保留在接口中以便用户去重新启动。接受该flag的activity可以使用autoRemoveFromRecents去复写这个request或者调用Activity.finishAndRemoveTask()方法。</p><p>FLAG_ACTIVITY_NEW_TASK</p><p>        设置此状态，记住以下原则，首先会查找是否存在和被启动的Activity具有相同的亲和性的任务栈（即taskAffinity，注意同一个应用程序中的activity的亲和性在没有修改的情况下是一样的，所以下面的a情况会在同一个栈中），如果有，刚直接把这个栈整体移动到前台，并保持栈中的状态不变，即栈中的activity顺序不变，如果没有，则新建一个栈来存放被启动的activity。</p><p>a. 前提: Activity A和Activity B在同一个应用中。</p><p>操作: Activity A启动开僻Task堆栈(堆栈状态：A)，在Activity A中启动Activity B， 启动Activity B的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Activity B被压入Activity A所在堆栈(堆栈状态：AB)。</p><p>原因: 默认情况下同一个应用中的所有Activity拥有相同的关系(taskAffinity)。</p><p>b. 前提: Activity A在名称为”TaskOne应用”的应用中， Activity C和Activity D在名称为”TaskTwo应用”的应用中。</p><p>操作1:在Launcher中单击“TaskOne应用”图标，Activity A启动开僻Task堆栈，命名为TaskA(TaskA堆栈状态: A)，在Activity A中启动Activity C， 启动Activity C的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Android系统会为Activity C开僻一个新的Task，命名为TaskB(TaskB堆栈状态: C), 长按Home键，选择TaskA，Activity A回到前台, 再次启动Activity C（两种情况：1.从桌面启动；2.从Activity A启动，两种情况一样）， 这时TaskB回到前台, Activity C显示，供用户使用, 即：包含FLAG_ACTIVITY_NEW_TASK的Intent启动Activity的Task正在运行，则不会为该Activity创建新的Task，而是将原有的Task返回到前台显示。</p><p>操作2:在Launcher中单击”TaskOne应用”图标，Activity A启动开僻Task堆栈，命名为TaskA(TaskA堆栈状态: A)，在Activity A中启动Activity C，启动Activity C的Intent的Flag设为FLAG_ACTIVITY_NEW_TASK，Android系统会为Activity C开僻一个新的Task，命名为TaskB(TaskB堆栈状态: C)， 在Activity C中启动Activity D(TaskB的状态: CD) 长按Home键， 选择TaskA，Activity A回到前台， 再次启动Activity C(从桌面或者ActivityA启动，也是一样的)，这时TaskB回到前台, Activity D显示，供用户使用。说明了在此种情况下设置FLAG_ACTIVITY_NEW_TASK后，会先查找是不是有Activity C存在的栈，根据亲和性(taskAffinity)，如果有，刚直接把这个栈整体移动到前台，并保持栈中的状态不变，即栈中的顺序不变。</p><p>FLAG_ACTIVITY_NO_ANIMATION</p><p>        启动的时候不执行动画。</p><p>FLAG_ACTIVITY_NO_USER_ACTION</p><p>        禁止activity调用onUserLeaveHint()函。onUserLeaveHint()作为activity周期的一部分，它在activity因为用户要跳转到别的activity而退到background时使用。比如，在用户按下Home键（用户的操作），它将被调用。比如有电话进来（不属于用户的操作），它就不会被调用。注意：通过调用finish()时该activity销毁时不会调用该函数。</p><p>FLAG_ACTIVITY_PREVIOUS_IS_TOP</p><p>        如果给Intent对象设置了这个标记，这个Intent对象被用于从一个存在的Activity中启动一个新的Activity，那么新的这个Activity不能用于接受发送给顶层activity的intent，这个新的activity的前一个activity被作为顶部activity。</p><p>FLAG_ACTIVITY_TASK_ON_HOME</p><p>        api11加入。把当前新启动的任务置于Home任务之上，也就是按back键从这个任务返回的时候会回到home，即使这个不是他们最后看见的activity，注意这个标记必须和FLAG_ACTIVITY_NEW_TASK一起使用。</p><p>FLAG_EXCLUDE_STOPPED_PACKAGES和FLAG_INCLUDE_STOPPED_PACKAGES</p><p>        从Android 3.1开始，给Intent定义了两个新的Flag，分别为FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，用来控制Intent是否要对处于停止状态的App起作用，顾名思义：</p><p>FLAG_INCLUDE_STOPPED_PACKAGES：表示包含未启动的App</p><p>FLAG_EXCLUDE_STOPPED_PACKAGES：表示不包含未启动的App</p><p>值得注意的是，Android 3.1开始，系统向所有Intent的广播添加了FLAG_EXCLUDE_STOPPED_PACKAGES标志。这样做是为了防止广播无意或不必要地开启未启动App的后台服务。如果要强制调起未启动的App，后台服务或应用程序可以通过向广播Intent添加FLAG_INCLUDE_STOPPED_PACKAGES标志来唤醒。</p><h3 id="常用Android-View的使用"><a href="#常用Android-View的使用" class="headerlink" title="常用Android View的使用"></a>常用Android View的使用</h3><ol><li>Views（TextView,ImageView,EditText,Button,Switch,CheckBox,RadioGroup,RadioButton,ToggleButton,WebView,ProgressBar,SeekBar）</li><li>ViewGroup(FrameLayout,RelativeLayout,ConstraintLayout,LinearLayout,GridLayout,ScrollView,ListView,TabHost)</li></ol><p>ConstraintLayout 优势：<br>    1). 所见即所得。易于在AndroidStudio中进行配置<br>    2). 和RelativeLayout一样，可以有效减少布局层数，从而降低绘制复杂度<br>    3). 和RelativeLayout相比，其布局方式更灵活，更容易适配多种机型。</p><p>ConstraintLayout的使用分析：<br>各种属性的使用：<br><a href="https://www.jianshu.com/p/17ec9bd6ca8a">https://www.jianshu.com/p/17ec9bd6ca8a</a><br><a href="https://www.jianshu.com/p/38ee0aa654a8">https://www.jianshu.com/p/38ee0aa654a8</a></p><p>ConstraintSet的使用：<br>ConstraintSet主要是方便在代码中修改ConstraintLayout的各种约束属性。<br>使用：<br><a href="http://hulkyang.blogspot.com/2018/12/android-constraintlayout-constraintset.html">http://hulkyang.blogspot.com/2018/12/android-constraintlayout-constraintset.html</a></p><h3 id="RecyclerView-使用"><a href="#RecyclerView-使用" class="headerlink" title="RecyclerView 使用"></a>RecyclerView 使用</h3><p><a href="https://www.jianshu.com/p/4f9591291365">https://www.jianshu.com/p/4f9591291365</a></p><p>RecyclerView的特点：</p><ol><li>默认实现的多级缓存机制</li><li>灵活的布局规则，有很强的可配置、可定制性，可实现多行多列，可多向滚动的List</li><li>通过LayoutManager，Adapter，ViewHolder，实现了布局和逻辑的解耦</li><li>可以局部刷新，并且可以通过ItemAnimation实现更丰富的动画效果</li></ol><p>RecyclerView的4级缓存机制：<br>RecylerView的多级缓存机制，是有RecyclerView中的内部类Recycler实现的。<br>其中最重要的方法：<br>getViewForPosition(int position)-&gt;getViewForPosition(int position, boolean dryRun) -&gt; tryGetViewHolderForPositionByDeadline(int position,<br>                boolean dryRun, long deadlineNs) </p><p>核心逻辑实现于tryGetViewHolderForPositionByDeadline中，其中从上个方法传递过来的参数中的dealineNs为Int.MaxValue.</p><p>第一步：判断是否处于isPreLayout状态，这个状态值只有在执行item动画的时候才会为true。如果是的话，则调用getChangedScrapViewForPosition（）方法获取viewHolder并返回</p><p>第二歩(核心步骤)：在isPreLayout=false的情况下，正常获取一个ViewHolder，需要先按照位置从scrap或者是hiden的或者是cachedView中找。如果说没有找到的话，就按照id和itemType在scrap和缓存中找；如果说没有找到合适的VH，那就判定是否有mViewCacheExtension的定义，有就从mViewCacheExtension中根据position和type找；如果还是没有找到合适的VH，下一个步骤就是在recyclerPool中根据type找</p><p>第三歩：如果都没有找到缓存的VH，则需要通过createViewHolder回调Adapter中的方法，进行创建ViewHolder。如果说缓存的VH的话判断是否需要绑定，需要的话就调用onBindViewHolder方法</p><h3 id="View-触摸事件传递机制"><a href="#View-触摸事件传递机制" class="headerlink" title="View 触摸事件传递机制"></a>View 触摸事件传递机制</h3><p>在应用中传递顺序：</p><blockquote><ol><li>Activity  dispatchTouchEvent</li></ol></blockquote><pre><code>            | </code></pre><blockquote><ol start="2"><li>PhoneWindow的superDispatchTouchEvent()方法</li></ol></blockquote><pre><code>            |</code></pre><blockquote><ol start="3"><li>DocerView的superDispatchTouchEvent()方法 调用super.dispatchTouchEvent</li></ol></blockquote><pre><code>            |</code></pre><blockquote><ol start="4"><li>ViewGroup dispatchTouchEvent DocerView继承自ViewGroup，so调用ViewGroup的dispatch方法(划重点：该方法完成主要的传递逻辑)</li></ol></blockquote><pre><code>            |</code></pre><blockquote><ol start="5"><li>ViewGroup中首先交由自己的onInterpretTouchEvent进行处理，如果说onInterpretTouchEvent返回true，那么事件被自身拦截，不会继续向下传递。如果不处理，则交由合适的子View进行处理，如果子view仍然是viewGroup则继续按照规则向下分发。如果没有子view则交由自身的touchEvent处理，如果都返回的false。touch事件将不再继续向下分发，而回到上一级的ViewGroup</li></ol></blockquote><pre><code>             |</code></pre><blockquote><ol start="6"><li>View 的dispatchTouchEvent中如果返回true，则交由该View进行处理，如果返回false，则继续由父View 进行处理。同理依次向上推导，直到回到Activity的dispatchTouchEvent方法。<br><a href="https://blog.csdn.net/fengluoye2012/article/details/83782042">https://blog.csdn.net/fengluoye2012/article/details/83782042</a></li></ol></blockquote><h3 id="View-KeyEvent传递机制"><a href="#View-KeyEvent传递机制" class="headerlink" title="View KeyEvent传递机制"></a>View KeyEvent传递机制</h3><p>和触摸事件的传递大同小异。相比较而言，KeyEvent事件会更加简单一些，因为触摸事件有ActionDown，ActionUp，中间还有若干次的ActionMove。</p><h3 id="View滚动事件分析，边际检测"><a href="#View滚动事件分析，边际检测" class="headerlink" title="View滚动事件分析，边际检测"></a>View滚动事件分析，边际检测</h3><h3 id="ViewPager使用和实现原理分析"><a href="#ViewPager使用和实现原理分析" class="headerlink" title="ViewPager使用和实现原理分析"></a>ViewPager使用和实现原理分析</h3><h3 id="Android-Jetpack"><a href="#Android-Jetpack" class="headerlink" title="Android Jetpack"></a>Android Jetpack</h3><p>Room:官方数据库Orm框架<br>LifeCycle： 构建生命周期感知型组件，这些组件可以根据 Activity 或 Fragment 的当前生命周期状态调整行为<br>WorkManager：满足您的后台调度需求<br>Navigation：管理应用流程<br>ViewModels： 帮助应用实现更好的MVVM架构<br>DataBinding： 主要是基于依赖注入实现配置化UI的框架，对比框架有ViewBindings，GreenOrm<br>ConstraintLayout: 主要是可以减少布局层数，实现更灵活的页面布局</p><h3 id="线程间通信方式有几种"><a href="#线程间通信方式有几种" class="headerlink" title="线程间通信方式有几种"></a>线程间通信方式有几种</h3><h3 id="为什么在Looper中while-true-取消息不会阻塞主线程，Looper，MessageQueue，Handler的关系"><a href="#为什么在Looper中while-true-取消息不会阻塞主线程，Looper，MessageQueue，Handler的关系" class="headerlink" title="为什么在Looper中while true 取消息不会阻塞主线程，Looper，MessageQueue，Handler的关系"></a>为什么在Looper中while true 取消息不会阻塞主线程，Looper，MessageQueue，Handler的关系</h3><h3 id="为什么不能在工作线程直接刷新UI"><a href="#为什么不能在工作线程直接刷新UI" class="headerlink" title="为什么不能在工作线程直接刷新UI"></a>为什么不能在工作线程直接刷新UI</h3><h3 id="Android-自定义View和ViewGroup需要实现的方法"><a href="#Android-自定义View和ViewGroup需要实现的方法" class="headerlink" title="Android 自定义View和ViewGroup需要实现的方法"></a>Android 自定义View和ViewGroup需要实现的方法</h3><h3 id="Android-draw，-onDraw-，onLayout，方法的区别和联系"><a href="#Android-draw，-onDraw-，onLayout，方法的区别和联系" class="headerlink" title="Android draw， onDraw ，onLayout，方法的区别和联系"></a>Android draw， onDraw ，onLayout，方法的区别和联系</h3><h3 id="Android-绘图相关-Paint-几种颜色混合模式"><a href="#Android-绘图相关-Paint-几种颜色混合模式" class="headerlink" title="Android 绘图相关 Paint 几种颜色混合模式"></a>Android 绘图相关 Paint 几种颜色混合模式</h3><h3 id="Android-Animation类型"><a href="#Android-Animation类型" class="headerlink" title="Android Animation类型"></a>Android Animation类型</h3><h3 id="如何优化图片加载"><a href="#如何优化图片加载" class="headerlink" title="如何优化图片加载"></a>如何优化图片加载</h3><h3 id="实现一个简单的LruCache"><a href="#实现一个简单的LruCache" class="headerlink" title="实现一个简单的LruCache"></a>实现一个简单的LruCache</h3><h3 id="Android中新增的几种数据类型"><a href="#Android中新增的几种数据类型" class="headerlink" title="Android中新增的几种数据类型"></a>Android中新增的几种数据类型</h3><p>SparseArray，IntSparseArray等</p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><h3 id="Android-Service相关知识"><a href="#Android-Service相关知识" class="headerlink" title="Android Service相关知识"></a>Android Service相关知识</h3><ol><li><p>生命周期。Service类型，两种方式 start&amp;bind区别 。</p></li><li><p>Service里面弹出Dialog的方式</p></li></ol><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>1.广播的类型</p><p>2.Broadcast ANR</p><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><ol><li><p>ContentProvider中使用的Context</p></li><li><p>ContentProvider的生命周期</p></li></ol><h2 id="Android-常用的系统服务"><a href="#Android-常用的系统服务" class="headerlink" title="Android 常用的系统服务"></a>Android 常用的系统服务</h2><h3 id="1-AMS"><a href="#1-AMS" class="headerlink" title="1. AMS"></a>1. AMS</h3><h3 id="2-PackageManagerService"><a href="#2-PackageManagerService" class="headerlink" title="2. PackageManagerService"></a>2. PackageManagerService</h3><h3 id="3-WindowManagerService"><a href="#3-WindowManagerService" class="headerlink" title="3. WindowManagerService"></a>3. WindowManagerService</h3><h3 id="4-InputManagerService"><a href="#4-InputManagerService" class="headerlink" title="4. InputManagerService"></a>4. InputManagerService</h3><h3 id="5-NotificationService"><a href="#5-NotificationService" class="headerlink" title="5. NotificationService"></a>5. NotificationService</h3><h3 id="6-AccountManagerService"><a href="#6-AccountManagerService" class="headerlink" title="6. AccountManagerService"></a>6. AccountManagerService</h3><h3 id="7-PowerManagerService"><a href="#7-PowerManagerService" class="headerlink" title="7. PowerManagerService"></a>7. PowerManagerService</h3><h2 id="Android-存储系统和存储优化相关内容"><a href="#Android-存储系统和存储优化相关内容" class="headerlink" title="Android 存储系统和存储优化相关内容"></a>Android 存储系统和存储优化相关内容</h2><h2 id="AndroidStudio相关"><a href="#AndroidStudio相关" class="headerlink" title="AndroidStudio相关"></a>AndroidStudio相关</h2><h3 id="AndroidStudio三方包管理工具maven"><a href="#AndroidStudio三方包管理工具maven" class="headerlink" title="AndroidStudio三方包管理工具maven"></a>AndroidStudio三方包管理工具maven</h3><h3 id="AndroidStudio-InstanceRun实现原理"><a href="#AndroidStudio-InstanceRun实现原理" class="headerlink" title="AndroidStudio InstanceRun实现原理"></a>AndroidStudio InstanceRun实现原理</h3><h2 id="简历上可能涉及到的内容"><a href="#简历上可能涉及到的内容" class="headerlink" title="简历上可能涉及到的内容"></a>简历上可能涉及到的内容</h2><h3 id="RN的原理"><a href="#RN的原理" class="headerlink" title="RN的原理"></a>RN的原理</h3><h3 id="Android应用-开发跨平台的几种流行方式（Native，Hybird，H5-WebView单页-）"><a href="#Android应用-开发跨平台的几种流行方式（Native，Hybird，H5-WebView单页-）" class="headerlink" title="Android应用 开发跨平台的几种流行方式（Native，Hybird，H5 +WebView单页 ）"></a>Android应用 开发跨平台的几种流行方式（Native，Hybird，H5 +WebView单页 ）</h3><h3 id="Kotlin相关知识"><a href="#Kotlin相关知识" class="headerlink" title="Kotlin相关知识"></a>Kotlin相关知识</h3><h2 id="Kotlin的一些优势分析"><a href="#Kotlin的一些优势分析" class="headerlink" title="Kotlin的一些优势分析"></a>Kotlin的一些优势分析</h2><h2 id="Kotlin-跨线程方案分析"><a href="#Kotlin-跨线程方案分析" class="headerlink" title="Kotlin 跨线程方案分析"></a>Kotlin 跨线程方案分析</h2><h2 id="Kotlin-一些语法特征"><a href="#Kotlin-一些语法特征" class="headerlink" title="Kotlin 一些语法特征"></a>Kotlin 一些语法特征</h2><h1 id="Java基础知识复习"><a href="#Java基础知识复习" class="headerlink" title="Java基础知识复习"></a>Java基础知识复习</h1><h2 id="Java5，Java6，Java7，Java8-11各版本feature"><a href="#Java5，Java6，Java7，Java8-11各版本feature" class="headerlink" title="Java5，Java6，Java7，Java8-11各版本feature"></a>Java5，Java6，Java7，Java8-11各版本feature</h2><h2 id="Java-语法"><a href="#Java-语法" class="headerlink" title="Java 语法"></a>Java 语法</h2><h3 id="数据类型，类接口和枚举"><a href="#数据类型，类接口和枚举" class="headerlink" title="数据类型，类接口和枚举"></a>数据类型，类接口和枚举</h3><h3 id="java-collection-api相关-List-Map-Table-Tree-Queue-Stack"><a href="#java-collection-api相关-List-Map-Table-Tree-Queue-Stack" class="headerlink" title="java collection api相关 List,Map,Table,Tree,Queue,Stack"></a>java collection api相关 List,Map,Table,Tree,Queue,Stack</h3><h3 id="Java-HashMap，Arraylist分析，"><a href="#Java-HashMap，Arraylist分析，" class="headerlink" title="Java HashMap，Arraylist分析，"></a>Java HashMap，Arraylist分析，</h3><h3 id="Java-concorrent-api-和多线程通信-线程池原理"><a href="#Java-concorrent-api-和多线程通信-线程池原理" class="headerlink" title="Java concorrent api 和多线程通信 线程池原理"></a>Java concorrent api 和多线程通信 线程池原理</h3><h3 id="Java-ThreadLocal原理"><a href="#Java-ThreadLocal原理" class="headerlink" title="Java ThreadLocal原理"></a>Java ThreadLocal原理</h3><h1 id="Android-Framework相关知识复习"><a href="#Android-Framework相关知识复习" class="headerlink" title="Android Framework相关知识复习"></a>Android Framework相关知识复习</h1><h2 id="Android-Binder-机制"><a href="#Android-Binder-机制" class="headerlink" title="Android Binder 机制"></a>Android Binder 机制</h2><h3 id="Binder-原理（上层，Linux层，-Kernel层）"><a href="#Binder-原理（上层，Linux层，-Kernel层）" class="headerlink" title="Binder 原理（上层，Linux层， Kernel层）"></a>Binder 原理（上层，Linux层， Kernel层）</h3><h3 id="Binder-的应用"><a href="#Binder-的应用" class="headerlink" title="Binder 的应用"></a>Binder 的应用</h3><h2 id="Android-跨进程通信的其他方式"><a href="#Android-跨进程通信的其他方式" class="headerlink" title="Android 跨进程通信的其他方式"></a>Android 跨进程通信的其他方式</h2><h2 id="Android-系统启动流程分析"><a href="#Android-系统启动流程分析" class="headerlink" title="Android 系统启动流程分析"></a>Android 系统启动流程分析</h2><h2 id="Android-应用启动分析"><a href="#Android-应用启动分析" class="headerlink" title="Android 应用启动分析"></a>Android 应用启动分析</h2><h2 id="Android-（JVM虚拟机）内存泄露的原理"><a href="#Android-（JVM虚拟机）内存泄露的原理" class="headerlink" title="Android （JVM虚拟机）内存泄露的原理"></a>Android （JVM虚拟机）内存泄露的原理</h2><h2 id="Android-ANR的定义"><a href="#Android-ANR的定义" class="headerlink" title="Android ANR的定义"></a>Android ANR的定义</h2><p>1、发生原因<br>一句话总结：没有在规定的时间内，干完要干的事情，就会发生ANR。</p><p>2、ANR分类<br>从发生的场景分类：</p><p>Input事件超过5s没有被处理完<br>Service处理超时，前台20s，后台200s<br>BroadcastReceiver处理超时，前台10S，后台60s<br>ContentProvider执行超时，比较少见</p><p>3、从发生的原因分：</p><p>主线程有耗时操作，如有复杂的layout布局，IO操作等。<br>被Binder对端block<br>被子线程同步锁block<br>Binder被占满导致主线程无法和SystemServer通信<br>得不到系统资源（CPU/RAM/IO）</p><p>4、从进程的角度分：</p><p>问题出在当前进程:<br>主线程本身耗时, 或则主线程的消息队列存在耗时操作;<br>主线程被本进程的其他子线程所blocked;<br>问题出在远端进程(一般是binder call或socket等通信方式)</p><h2 id="Android-输入事件的产生和传递机制分析"><a href="#Android-输入事件的产生和传递机制分析" class="headerlink" title="Android 输入事件的产生和传递机制分析"></a>Android 输入事件的产生和传递机制分析</h2><h2 id="Android-apk打包流程分析和apk的签名机制"><a href="#Android-apk打包流程分析和apk的签名机制" class="headerlink" title="Android apk打包流程分析和apk的签名机制"></a>Android apk打包流程分析和apk的签名机制</h2><h2 id="Android-中View的底层绘制原理Chaerographer和SurfaceFlinger"><a href="#Android-中View的底层绘制原理Chaerographer和SurfaceFlinger" class="headerlink" title="Android 中View的底层绘制原理Chaerographer和SurfaceFlinger"></a>Android 中View的底层绘制原理Chaerographer和SurfaceFlinger</h2><h2 id="Android-丢帧-冻帧-和帧率优化相关知识分析"><a href="#Android-丢帧-冻帧-和帧率优化相关知识分析" class="headerlink" title="Android 丢帧 冻帧 和帧率优化相关知识分析"></a>Android 丢帧 冻帧 和帧率优化相关知识分析</h2><h2 id="Android-各个主要版本的Feature"><a href="#Android-各个主要版本的Feature" class="headerlink" title="Android 各个主要版本的Feature"></a>Android 各个主要版本的Feature</h2><h2 id="Android-编译系统相关知识-make-mk-bp-，Aosp库各个目录的作用。以及主要版本的演进Android5-1，Android-6-0-Android-8-0-Android-9-0"><a href="#Android-编译系统相关知识-make-mk-bp-，Aosp库各个目录的作用。以及主要版本的演进Android5-1，Android-6-0-Android-8-0-Android-9-0" class="headerlink" title="Android 编译系统相关知识 make .mk,.bp ，Aosp库各个目录的作用。以及主要版本的演进Android5.1，Android 6.0,Android 8.0,Android 9.0"></a>Android 编译系统相关知识 make .mk,.bp ，Aosp库各个目录的作用。以及主要版本的演进Android5.1，Android 6.0,Android 8.0,Android 9.0</h2><h2 id="Android-selinux-相关知识-sepolicy的定义，生成。"><a href="#Android-selinux-相关知识-sepolicy的定义，生成。" class="headerlink" title="Android selinux 相关知识 sepolicy的定义，生成。"></a>Android selinux 相关知识 sepolicy的定义，生成。</h2><h2 id="Android-内存优化相关内容"><a href="#Android-内存优化相关内容" class="headerlink" title="Android 内存优化相关内容"></a>Android 内存优化相关内容</h2><h2 id="Android-I-O优化相关内容"><a href="#Android-I-O优化相关内容" class="headerlink" title="Android I/O优化相关内容"></a>Android I/O优化相关内容</h2><h3 id="Linux-I-O-的基本组成"><a href="#Linux-I-O-的基本组成" class="headerlink" title="Linux I/O 的基本组成"></a>Linux I/O 的基本组成</h3><p>众所周知，Android 基于 Linux 系统，先介绍一些 Linux 上 I/O 的知识。</p><ol><li>I/O 操作由应用程序、文件系统和磁盘共同完成，应用程序将 I/O 命令发送给文件系统，文件系统在合适的时间把 I/O 指令发送给磁盘。I/O 的流程如下图：</li></ol><p><img src="images/interview/image/io1.webp" alt="io流程图"></p><p>CPU 和内存的速度比磁盘快得多，I/O 操作的瓶颈在于磁盘的性能。为了降低磁盘对应用程序的影响，文件系统要进行各种各样的优化。</p><ol start="2"><li><p>文件系统<br>简单来说，文件系统就是存储和组织数据的方式。应用程序调用 read() 方法，系统会通过中断从用户空间进入内核空间，然后经过虚拟文件系统、具体文件系统、页缓存。<br><img src="images/interview/image/io2.webp" alt="文件系统"></p><ul><li>虚拟文件系统（VFS）。主要用于屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。</li><li>文件系统（File System）。ext4、F2FS 都是具体文件系统实现。每个文件系统都有适合自己的场景。</li><li>页缓存（Page Cache）。文件系统对数据的缓存，读文件时先检查页缓存，如果命中就不去读磁盘。</li></ul></li></ol><ol start="3"><li>磁盘<br>磁盘指的是系统的存储设备，常见的有机械硬盘、固态硬盘等。如果发现应用程序要读的数据没有在页缓存中，这时候就需要真正向磁盘发起 I/O 请求。磁盘 I/O 的过程要先经过内核的通用块层、I/O 调度层、设备驱动层，最后才会交给具体的硬件设备处理。</li></ol><p><img src="images/interview/image/io3.webp" alt="磁盘调度架构图"></p><p>磁盘架构</p><ul><li>通用块层。接收上层发出的磁盘请求，并最终发出 I/O 请求。它与 VPS 的作用类似。</li><li>I/O 调度层。根据设置的调度算法对请求合并和排序。不能接收到磁盘请求就立刻交给驱动层处理。</li><li>块设备驱动层。根据具体的物理设备，选择对应的驱动程序，通过操控硬件设备完成最终的 I/O 请求。</li></ul><h3 id="Android-IO"><a href="#Android-IO" class="headerlink" title="Android IO"></a>Android IO</h3><ol><li><p>文件系统： Android普遍采用的是ext4的文件系统，以及f2fs（2012三星针对为闪存研发的文件系统，它针对闪存进行了大量优化，F2FS 文件系统在小文件的随机读写方面比 ext4 更快，<strong>随机写性能提高</strong>），目前还有只在华为上应用的，华为自研的EROFS（2018年6月，华为工程师在开源社区展示了基于Linux的全新只读文件系统EROFS（Extendable Read-Only File System），采用改进的压缩算法，致力于提高文件访问性能，特别是<strong>随机读</strong>性能。根据当时公布的测试数据，可以看到执行随机读取数据时，EROFS有着一边倒的优势，并且文件压缩率越小时优势越明显：当文件压缩率为4%（即100MB文件压缩为4MB）时，提升高达172%。在EROFS面世后的半年多里，华为工程师对其持续打磨，终于在P30上实现了规模商用）</p></li><li><p>磁盘格式： Android 使用的闪存主流有2种类型，一种是emmc（Embedded Multi Media Card），另外一种是UFS（2.0,2.1），USF的读写速度更快，性能更好（最高速度在300MB/s以下的大几率都是eMMC，在500MB/s附近则可能是UFS 2.0，在700MB/s以上则较大可能是UFS 2.1了）</p><ul><li><p>查看磁盘类型方法：<code>ls /proc/fs/*</code> ；在ext4文件系统下如果看到很多个emmc-blkxxx，则是emmc的 ，如果说文件系统为f2fs的就继续查看 <code>ls /proc/fs/f2fs/</code>下，如果说以sd开头则是ufs居多。</p></li><li><p>另外，如果说是ext4的文件系统，查看emmc-blk+数字对应的具体分区的方法：</p><blockquote><p><code>ls -l /dev/block/platform/ff0f0000.rksdmmc/by-name/</code></p></blockquote></li></ul></li><li><p>手机变卡<br>Android 手机用久了会变卡，除了系统升级、设备折旧等因素，还和 I/O 有密切关系。I/O 操作变慢的原因有下面几条：</p><ul><li><p>内存不足。系统回收 Page Cache 和 Buffer Cache 的内存，大部分的写操作会直接落盘，导致性能低下。</p></li><li><p>写入放大<br>闪存重复写入需要先进行擦除，一次写入会引起整个块数据的迁移，导致写入时间非常久。</p></li><li><p>设备性能差<br>在高负载的情况下容易出现瓶颈。</p></li><li><p>文件损坏<br>文件损坏是令人头疼的问题，大多是由不正确的操作导致的。文件损坏的原因可以从应用程序、    文件系统和磁盘三个角度来分析：</p><ul><li>应用程序。<br>大部分的 I/O 方法都不是原子操作，文件的跨进程或者多线程写入、使用一个已经关闭的文件描述符 fd 来操作文件，都有可能导致数据被覆盖或者删除。</li><li>文件系统。虽说内核崩溃或者系统突然断电都有可能导致文件系统损坏，不过文件系统也做了很多的保护措施。例如 system 分区保证只读不可写，增加异常检查和恢复机制。</li><li>磁盘。手机上使用的闪存是电子式的存储设备，所以在资料传输过程可能会发生电子遗失等现象导致数据错误。</li></ul></li></ul></li><li><p>I/O 操作的类型</p></li></ol><p>总体分为，标准IO，mmap,直接IO三种类型。</p><p><img src="images/interview/image/io4.webp" alt="IO操作类型"></p><pre><code>1. 标准 I/O应用程序平时用到 read/write 操作都属于标准 I/O，也就是缓存 I/O（Buffered I/O）。它的关键特性有：    - 对于读操作，当应用程序读取某块数据时，如果这块数据已经在页缓存中，那么就不需要经过物理读盘操作。    - 对于写操作，应用程序会先将数据写到页缓存中去，不需要等全部数据被写回磁盘，系统会定期将页缓存中的数据刷到磁盘上。    - 缓存 I/O 可以很大程度减少真正读写磁盘的次数，从而提升性能。但是延迟写机制可能会导致数据丢失。在实际应用中，如果某些数据非常重要，我们应该采用同步写机制。    - 读操作时，数据会先从磁盘拷贝到 Page Cache 中，然后再从 Page Cache 拷贝到应用程序的用户空间，这样就会多一次内存拷贝。内存相对磁盘是高速设备，即使多拷贝一次，也比真正读一次硬盘要快。2. mmapmmap 把文件映射到进程的地址空间，提高了 I/O 的性能。mmap 的优点有：    - 减少系统调用。只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样。    - 减少数据拷贝。mmap 只需要从磁盘拷贝一次，由于做过内存映射，不需要再拷贝回用户空间。    - 可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样。存在的缺点：    - 虚拟内存增大。Apk、Dex、so 都是通过 mmap 读取。mmap 会导致虚拟内存增大，mmap 大文件容易出现 OOM。    - 磁盘延迟。mmap 通过缺页中断向磁盘发起真正的磁盘 I/O，不能通过 mmap 消除磁盘 I/O 的延迟。在 Android 中可以将文件通过 MemoryFile 或者 MappedByteBuffer 映射到内存，然后进行读写，使用这种方式对于小文件和频繁读写操作的文件还是有一定优势的。mmap 比较适合对同一块区域频繁读写的情况，推荐使用 I/O 线程来操作。用户日志、数据上报都满足这种场景，另外需要跨进程同步的时候，mmap 也是一个不错的选择。Android 跨进程通信有自己独有的 Binder 机制，它内部也是使用 mmap 实现。3. Direct I/O一些数据库自己实现了数据和索引的缓存管理，对页缓存的依赖没那么强烈。它们想绕开页缓存机制，减少一次数据拷贝，它的数据也不会污染页缓存。直接 I/O 访问文件方式减少了一次数据拷贝和一些系统调用的耗时，很大程度降低了 CPU 的使用率以及内存的占用。负面影响就是读写操作都是同步执行，导致应用程序等待。4. 同步与异步 I/O多线程阻塞式在 I/O 操作上的并没有优势，I/O 操作的主要瓶颈在于磁盘带宽。所以 I/O 操作不能开大量的线程。NIO 是非阻塞 I/O，将 I/O 以事件的方式通知，可以减少线程切换的开销。NIO 的最大作用不是减少读取文件的耗时，而是最大化提升应用整体的 CPU 利用率。另外，非常推荐 Square 的 Okio，它支持同步和异步 I/O，也做了比较多的优化。</code></pre><p>I/O 优化对提升应用的体验非常有用，希望上面所讲的内容对你有帮助。</p><p>作者：落英坠露<br>链接：<a href="https://www.jianshu.com/p/43af9c156674">https://www.jianshu.com/p/43af9c156674</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ol start="5"><li><p>IO优化</p><ol><li><p>emmc 擦写次数和判断 emmc 使用寿命是否到期方法</p></li><li><p>查看系统整体的 io 状态</p><p> 2.1 iostat</p><p> 比如说我们想查看当前系统的 io 状态，以 kb/s　作为单位:    </p></li></ol></li></ol><pre><code>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1|root@rk3368:/ # busybox iostat -k -d                                </span><br><span class="line">Linux 3.10.0 (localhost) 03/03/21 _aarch64_(8 CPU)</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">mmcblk0          70.26      1981.90       269.29  225512879   30641156</span><br><span class="line">mmcblk0p7         0.00         0.18         0.00      20288          0</span><br><span class="line">mmcblk0p9         0.00         0.00         1.10        305     124868</span><br><span class="line">mmcblk0p11        3.70       228.62         0.00   26013646         16</span><br><span class="line">mmcblk0p12        0.00         0.00         0.11        474      11992</span><br><span class="line">mmcblk0p15       59.42      1753.10       268.08  199478166   30504280</span><br></pre></td></tr></table></figure>    比如说我们想查看当前系统的 io 状态，以 kb/s　作为单位，并且没两分钟统计一次，共5次:    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busybox iostat -d -k  2 5</span><br></pre></td></tr></table></figure>    2.2 iotop    iostat　只能查看系统的整体 io　状态，当 io 状态异常高时，　不能定位是哪个进程引起的问题，　这时我们可以使用 iotop 这个工具来查看每个进程的 io 占用比例。但是iotop只在Android9.0以上才原生集成，低版本系统，需要push Github开源脚本 [iotop.sh](&#39;https://github.com/laufersteppenwolf/iotop&#39;). 但是该脚本我在使用过程中发现会有不能用的情况，提示`Your kernel does not support I/O accounting,    which is required for this tool to work :(`    2.3 vmstat    vmstat是一个非常有用的脚本，用来查看虚拟机当前的一些状态数据。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 2</span><br></pre></td></tr></table></figure>    2.4 http://qiushao.net/2020/02/11/Android/iostat/    iotop　只可以查看某个时间点的 io 速率，　我们需要统计某个进程总共的 io 总量时就得使用　cat /proc/$pid/io 这个方法了。</code></pre><h2 id="Android-性能优化相关内容"><a href="#Android-性能优化相关内容" class="headerlink" title="Android 性能优化相关内容"></a>Android 性能优化相关内容</h2><h1 id="HTTP相关知识"><a href="#HTTP相关知识" class="headerlink" title="HTTP相关知识"></a>HTTP相关知识</h1><h2 id="HTTP三次握手和四次挥手"><a href="#HTTP三次握手和四次挥手" class="headerlink" title="HTTP三次握手和四次挥手"></a>HTTP三次握手和四次挥手</h2><h2 id="HTTP协议演进（HTTP1-0-1-1-2-0）"><a href="#HTTP协议演进（HTTP1-0-1-1-2-0）" class="headerlink" title="HTTP协议演进（HTTP1.0,1.1,2.0）"></a>HTTP协议演进（HTTP1.0,1.1,2.0）</h2><h2 id="HTTPS-加密方式（对称加密，非对称加密）"><a href="#HTTPS-加密方式（对称加密，非对称加密）" class="headerlink" title="HTTPS 加密方式（对称加密，非对称加密）"></a>HTTPS 加密方式（对称加密，非对称加密）</h2><h2 id="HTTP-协议详解，Head-Body分析"><a href="#HTTP-协议详解，Head-Body分析" class="headerlink" title="HTTP 协议详解，Head Body分析"></a>HTTP 协议详解，Head Body分析</h2><h1 id="虚拟机相关"><a href="#虚拟机相关" class="headerlink" title="虚拟机相关"></a>虚拟机相关</h1><h2 id="JVM虚拟机的内存模型"><a href="#JVM虚拟机的内存模型" class="headerlink" title="JVM虚拟机的内存模型"></a>JVM虚拟机的内存模型</h2><h2 id="Android虚拟机（Dalvik-art）虚拟机内存模型和特点"><a href="#Android虚拟机（Dalvik-art）虚拟机内存模型和特点" class="headerlink" title="Android虚拟机（Dalvik,art）虚拟机内存模型和特点"></a>Android虚拟机（Dalvik,art）虚拟机内存模型和特点</h2><h2 id="Android-应用-启动流程虚拟机流程分析"><a href="#Android-应用-启动流程虚拟机流程分析" class="headerlink" title="Android 应用 启动流程虚拟机流程分析"></a>Android 应用 启动流程虚拟机流程分析</h2><h2 id="Android-虚拟机的垃圾回收机制"><a href="#Android-虚拟机的垃圾回收机制" class="headerlink" title="Android 虚拟机的垃圾回收机制"></a>Android 虚拟机的垃圾回收机制</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="工厂模式，简单工厂"><a href="#工厂模式，简单工厂" class="headerlink" title="工厂模式，简单工厂"></a>工厂模式，简单工厂</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="设计模式的几大原则"><a href="#设计模式的几大原则" class="headerlink" title="设计模式的几大原则"></a>设计模式的几大原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h1 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-基础知识复习&quot;&gt;&lt;a href=&quot;#Android-基础知识复习&quot; class=&quot;headerlink&quot; title=&quot;Android 基础知识复习&quot;&gt;&lt;/a&gt;Android 基础知识复习&lt;/h1&gt;&lt;h2 id=&quot;Activity&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>用python爬取网易金融股票每日数据并存入MySql数据库</title>
    <link href="http://haijiaogao.github.io/blogs/2021/01/28/use-python2-7-crawl-Netease-stock-daily-data-into-mysql-db/"/>
    <id>http://haijiaogao.github.io/blogs/2021/01/28/use-python2-7-crawl-Netease-stock-daily-data-into-mysql-db/</id>
    <published>2021-01-28T10:01:12.815Z</published>
    <updated>2021-01-28T11:00:50.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>唱老师最近研究股票和基金，每日盯着手机几个金融软件，有天突发其想给我提了个需求：是否有抓取某几只股票一段时间内的股票数据的接口？我想了想，查了查，网上好多人都这么干过。于是翻了几篇帖子和github上一些开源的库，开搞。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote><p>数据其实可以存成csv的文件，后期可以用python的pandas软件进行数据分析，但是我因为对python了解的不太多，还是从自己熟悉的存到数据库入手，但是，其实差不多。但是存到数据库会有更多的坑需要一一去趟。</p></blockquote><ol><li>ubuntu 安装mysql-server以及相关包，并配置 mysql<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo apt-get install python-mysqldb</span><br><span class="line">sudo apt-get install libmysqlclient-dev </span><br></pre></td></tr></table></figure>其中第一个<code>mysql-server</code>装完了之后，就可以对mysql数据库进行配置，具体配置步骤如链接：<a href="'https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04'">DegitalOcean</a></li></ol><p>后面两个都是为了python连接mysql数据库用的。</p><ol start="2"><li><p>python 安装相关包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br><span class="line">pip install requests</span><br><span class="line">pip install lxml</span><br><span class="line">pip install MySQL-python</span><br><span class="line">pip install mysql-connector-python</span><br></pre></td></tr></table></figure><p> 2.1 使用python venv环境模拟python2.7环境，进行开发<br>由于python2.7 的版本已经不再维护了，所以在使用pip下载包的时候会频繁的报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https:&#x2F;&#x2F;pip.pypa.io&#x2F;en&#x2F;latest&#x2F;development&#x2F;release-process&#x2F;#python-2-support pip 21.0 will remove support for this functionality</span><br></pre></td></tr></table></figure><p>所以使用了<a href="'https://docs.python.org/3/tutorial/venv.html'">venv</a>,这样就可以方便的使用pip了，同时还可以分离开项目的依赖和系统python环境的依赖。<br> 2.2 pyCharm社区版安装<br>PyCharm社区版<code>https://www.jetbrains.com/pycharm/download/#section=linux</code></p></li></ol><h1 id="网易股票数据接口"><a href="#网易股票数据接口" class="headerlink" title="网易股票数据接口"></a>网易股票数据接口</h1><p>非常简单，大概是这样事儿的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D; &#39;http:&#x2F;&#x2F;quotes.money.163.com&#x2F;trade&#x2F;lsjysj_&#39; + 股票代码 + &#39;.html?year&#x3D;&#39; + 年份（2020） + &#39;&amp;season&#x3D;&#39; + 季度（1,2,3,4）</span><br></pre></td></tr></table></figure><p>返回的是一个html的页面，里面包含数据表格，需要使用python request模拟请求，并用beautifulSoup处理html，把数据整出来，存到mysql数据库中。</p><p>这里基本上是抄的别人的，没有什么技术难点，难点或许是在于对mysql数据库的操作上。但是也并不很复杂。</p><p>项目地址：<a href="'https://github.com/haijiaogao/stockDemo.git'">Github:</a></p><h1 id="TODo"><a href="#TODo" class="headerlink" title="TODo"></a>TODo</h1><p>项目仅仅实现了数据导入的功能，后续还有很多目标：</p><ol><li>数据Web展示</li><li>唱老师说需要知道某只股票的市值信息，以及盈利数据信息。<br>看了一下，接口都有，可以取到数据，难点在于接口很多，对于业务不了解的情况来说需要辨别那些是真的有用的那些是无用的。此处感觉更复杂。</li><li>数据分析 </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;唱老师最近研究股票和基金，每日盯着手机几个金融软件，有天突发其想给我提了个需求：是否有抓取某几只股票一段时间内的股票数据的接口？我想了想，查</summary>
      
    
    
    
    
    <category term="python" scheme="http://haijiaogao.github.io/blogs/tags/python/"/>
    
    <category term="mysql" scheme="http://haijiaogao.github.io/blogs/tags/mysql/"/>
    
    <category term="ubuntu" scheme="http://haijiaogao.github.io/blogs/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>2021年1月摸鱼计划</title>
    <link href="http://haijiaogao.github.io/blogs/2021/01/20/efforts-of-2021-1th/"/>
    <id>http://haijiaogao.github.io/blogs/2021/01/20/efforts-of-2021-1th/</id>
    <published>2021-01-20T09:42:29.038Z</published>
    <updated>2021-01-20T10:20:29.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021年1月工作-摸鱼-计划"><a href="#2021年1月工作-摸鱼-计划" class="headerlink" title="2021年1月工作(摸鱼)计划"></a>2021年1月<del>工作</del>(摸鱼)计划</h1><ul><li><p><input disabled="" type="checkbox">  考勤相关</p><ul><li><input checked="" disabled="" type="checkbox"> 抓包拿到考勤数据链接，以及打卡链接</li><li><input checked="" disabled="" type="checkbox"> 利用curl和fecth.js 模拟打卡和查询当日考勤</li><li><input checked="" disabled="" type="checkbox"> 使用bark ，发送打卡提醒</li><li><input disabled="" type="checkbox"> 定时运行脚本，查看当日打卡并发送忘打卡推送到手机</li></ul></li><li><p><input disabled="" type="checkbox">  树莓派相关</p><ul><li><input checked="" disabled="" type="checkbox"> 解决树莓派突然连不上wifi的问题，（究极原因，是因为我设置了静态ip，但是设置有误，导致重启之后，无法正常获取到ip）</li><li><input disabled="" type="checkbox"> 在树莓派上装了一个clash的客户端，想在家里搭一个透明代理(未完成)</li></ul></li></ul><ul><li><p><input checked="" disabled="" type="checkbox">  clash相关</p><ul><li><input checked="" disabled="" type="checkbox"> 更新clash版本，由于配置文件变动较大，重新配置了ubuntu电脑</li></ul></li><li><p><input disabled="" type="checkbox">  博客相关</p><ul><li><input checked="" disabled="" type="checkbox"> 更新了hexo的版本，由于版本变动较大，google后重新配置了hexo和next主题内容</li><li><input disabled="" type="checkbox"> 写新的博客内容（To be continued）</li></ul></li><li><p><input disabled="" type="checkbox">  Frp相关</p><ul><li><input checked="" disabled="" type="checkbox"> 利用我的aws ec2，实现了穿透到我的内网电脑</li><li><input checked="" disabled="" type="checkbox"> 利用cron实现了内网电脑需要登录才能联网的问题</li><li><input disabled="" type="checkbox"> 但像优秀的其他同事那样利用frp内网主机做ss代理</li></ul></li><li><p><input disabled="" type="checkbox">  Android（To be continued）</p><ul><li><input disabled="" type="checkbox"> kotlin网络框架，基础项目架构搭建</li><li><input disabled="" type="checkbox"> 实现<strong>华为智慧屏的focus效果</strong>自定义view</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2021年1月工作-摸鱼-计划&quot;&gt;&lt;a href=&quot;#2021年1月工作-摸鱼-计划&quot; class=&quot;headerlink&quot; title=&quot;2021年1月工作(摸鱼)计划&quot;&gt;&lt;/a&gt;2021年1月&lt;del&gt;工作&lt;/del&gt;(摸鱼)计划&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="个人" scheme="http://haijiaogao.github.io/blogs/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Difference between ConcurrentHashMap and HashMap</title>
    <link href="http://haijiaogao.github.io/blogs/2020/11/06/blog/java/concurrentHashMap/index/"/>
    <id>http://haijiaogao.github.io/blogs/2020/11/06/blog/java/concurrentHashMap/index/</id>
    <published>2020-11-06T02:54:17.000Z</published>
    <updated>2020-11-06T02:54:17.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConcorrentHashMap和HashMap的区别"><a href="#ConcorrentHashMap和HashMap的区别" class="headerlink" title="ConcorrentHashMap和HashMap的区别"></a>ConcorrentHashMap和HashMap的区别</h2><ol><li>ConcorrentHashMap 是线程安全(写入数据的时候加锁，读取不加锁)的，而HashMap是非线程安全的（写入和读取都没有加同步）。</li><li>ConcorrentHashMap 和 HashTable 类似，两者都是线程安全，而且不允许null key和null value，如果遇到会抛出NullPointerException异常，HashMap是可以写入空的key和Value的<br>但是HashTable的缺点是，它的写入和读取操作加锁（整表锁住），所以多线程的共享的情况下，效率会比较低。实际上应用比较少，但是因为历史问题（java legency 用到），所以予以保留，ConcorrentHashMap相当于是其升级版本。<br>ConcorrentHashMap优势：<ol><li>读取不加锁。</li><li>写入的时候加锁但是不是锁住整表，只是锁住变化的部分。</li></ol></li><li>ConcorrentHashMap在遍历的时候删除，不会抛出ConcorrentModifierException异常，HashMap会抛出异常。</li></ol><h2 id="HashMap-多线程同步的实现方式"><a href="#HashMap-多线程同步的实现方式" class="headerlink" title="HashMap 多线程同步的实现方式"></a>HashMap 多线程同步的实现方式</h2><p>Java的Collections中提供了Collections.synchronizedMap()方法，可以对不安全的Map，进行包装，同理，也可以通过其他的Collections.synchronizedAPI().对非线程安全的容器进行同步包装，实现同步。</p><h2 id="HashMap-amp-TreeMap-amp-LinkedHashMap-amp-HashTable对比"><a href="#HashMap-amp-TreeMap-amp-LinkedHashMap-amp-HashTable对比" class="headerlink" title="HashMap&amp;TreeMap&amp;LinkedHashMap&amp;HashTable对比"></a>HashMap&amp;TreeMap&amp;LinkedHashMap&amp;HashTable对比</h2><p><img src="images/sDoih.png" alt="HashMap&amp;TreeMap&amp;LinkedHashMap&amp;HashTable对比"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ConcorrentHashMap和HashMap的区别&quot;&gt;&lt;a href=&quot;#ConcorrentHashMap和HashMap的区别&quot; class=&quot;headerlink&quot; title=&quot;ConcorrentHashMap和HashMap的区别&quot;&gt;&lt;/a&gt;Co</summary>
      
    
    
    
    <category term="Java" scheme="http://haijiaogao.github.io/blogs/categories/Java/"/>
    
    
    <category term="Java" scheme="http://haijiaogao.github.io/blogs/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一次ubuntu备份重装系统始末</title>
    <link href="http://haijiaogao.github.io/blogs/2020/11/01/ubuntu/reinstall-ubuntu/index/"/>
    <id>http://haijiaogao.github.io/blogs/2020/11/01/ubuntu/reinstall-ubuntu/index/</id>
    <published>2020-11-01T03:02:43.000Z</published>
    <updated>2020-11-06T03:11:22.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重装系统总结"><a href="#重装系统总结" class="headerlink" title="重装系统总结"></a>重装系统总结</h2><h3 id="1-备份系统所在磁盘："><a href="#1-备份系统所在磁盘：" class="headerlink" title="1. 备份系统所在磁盘："></a>1. 备份系统所在磁盘：</h3><p>１．~/.*   所有常用的应用的以.开头的文件可以都copy下来，我并没有，我只copy了 .vim .oh-my-zsh .ssh  .git  ，但是在用的过程中发现有些没有考全，如bin/（在.bashrc和.zshrc文件中有引用到的目录）以及/opt目录下的所有的内容等</p><p>2．document/常用软件，项目文件等<br>3. desktop/日常文件等，这个其实只是单纯备份，用的时候再解压也一样</p><h3 id="2-重装后工作"><a href="#2-重装后工作" class="headerlink" title="2.重装后工作"></a>2.重装后工作</h3><h3 id="首先是apt-update，然后安装各种包-vim-git-autojump-chrome-openjdk-sublime等以及编译相关的"><a href="#首先是apt-update，然后安装各种包-vim-git-autojump-chrome-openjdk-sublime等以及编译相关的" class="headerlink" title="首先是apt-update，然后安装各种包(vim,git,autojump,chrome ,openjdk,sublime等以及编译相关的)"></a>首先是apt-update，然后安装各种包(vim,git,autojump,chrome ,openjdk,sublime等以及编译相关的)</h3><blockquote><p>open-jdk，chrome，sublime等需要单独添加源以及key。</p></blockquote><h3 id="搜狗输入法环境搭建"><a href="#搜狗输入法环境搭建" class="headerlink" title="搜狗输入法环境搭建"></a>搜狗输入法环境搭建</h3><ol><li>下载deb包：官网下载，很小，几乎不用备份</li><li>shell执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i sogouxxx.deb</span><br><span class="line"></span><br><span class="line">sudo apt install -f</span><br></pre></td></tr></table></figure></li><li>打开设置，languagueand locale,增加中文语言，安装语言相关更新，切换输入接口为fcitx,系统默认为ibus,然后重启</li></ol><p>4.重启后，右上角可以配置fxitx，添加输入法，取消掉当前语言小钩钩，然后搜索sogou,并添加，就可以输入中文了。</p><p>参考：<code>https://www.jianshu.com/p/cafe12618293</code></p><h3 id="网络环境搭建"><a href="#网络环境搭建" class="headerlink" title="网络环境搭建"></a>网络环境搭建</h3><ol><li>clash</li></ol><p>用的备份的<code>clash-linux-amd64-v0.19.0.gz</code>，解压文件.然后mv to /opt ，最后ln到usr/bin/clash</p><p>把备份的配置文件放在~/.config/clash下面之后就可以在命令行执行clash 启动应用了</p><h3 id="备份文件的还原"><a href="#备份文件的还原" class="headerlink" title="备份文件的还原"></a>备份文件的还原</h3><p>主要就是我备份的那些软件，配置等等。</p><h3 id="一些没有备份的工作以及日常应用的安装："><a href="#一些没有备份的工作以及日常应用的安装：" class="headerlink" title="一些没有备份的工作以及日常应用的安装："></a>一些没有备份的工作以及日常应用的安装：</h3><p>** sublime **</p><p>1.安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><ol start="2"><li>Import the repository’s GPG key using the following curl command :</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;download.sublimetext.com&#x2F;sublimehq-pub.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>3.Add the Sublime Text APT repository to your system’s software repository list by typing:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb https:&#x2F;&#x2F;download.sublimetext.com&#x2F; apt&#x2F;stable&#x2F;&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>Once the repository is enabled, update apt sources and install Sublime Text 3 with the following commands:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install sublime-text</span><br></pre></td></tr></table></figure><p>5.完成，首次打开时需要输入License，搜索到有效的license来自<code>https://gist.github.com/mehedicsit/7389e31b7857b377870a32e91be1c7c5</code></p><p>如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thanks GUys use this oone</span><br><span class="line"></span><br><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">Member J2TeaM</span><br><span class="line">Single User License</span><br><span class="line">EA7E-1011316</span><br><span class="line">D7DA350E 1B8B0760 972F8B60 F3E64036</span><br><span class="line">B9B4E234 F356F38F 0AD1E3B7 0E9C5FAD</span><br><span class="line">FA0A2ABE 25F65BD8 D51458E5 3923CE80</span><br><span class="line">87428428 79079A01 AA69F319 A1AF29A4</span><br><span class="line">A684C2DC 0B1583D4 19CBD290 217618CD</span><br><span class="line">5653E0A0 BACE3948 BB2EE45E 422D2C87</span><br><span class="line">DD9AF44B 99C49590 D2DBDEE1 75860FD2</span><br><span class="line">8C8BB2AD B2ECE5A4 EFC08AF2 25A9B864</span><br><span class="line">------ END LICENSE ------​</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.install package manager,由于我配置了代理，直接ctrl+shift+p ,输入install package 之后回车就安装成功了，如果不成功可参考网上其他方案</p><p>electronic-wechat</p><p>参考：<code>https://www.linuxbabe.com/desktop-linux/install-wechat-linux</code></p><p>由于我有备份electronic-wechat的zip包，所以采用直接解压缩安装的方式：<br>How To Install Electronic Wechat on Linux via Tarball<br>This is a traditional way to install Wechat on Linux. Go to github and download the tar.gz file. Choose linux-x64.tar.gz or linux-ia32.tar.gz according to your OS architecture. Once downloaded, open a terminal window and navigate to the download folder where the tar.gz file is located. Then issue the following command to extract it.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvf linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">unzip electronic-wechat-linux-x64-2.3.1.zip -d electronic-wechat</span><br></pre></td></tr></table></figure><p>打开electronic-wechat目录后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;electronic-wechat</span><br></pre></td></tr></table></figure><p>下面步骤为了方便使用，并非必须</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mv &#123;path to electronic-wechat&#125;&#x2F;electronic-wechat-linux-x64 &#x2F;opt</span><br><span class="line"></span><br><span class="line">sudo ln -s &#x2F;opt&#x2F;electronic-wechat-linux-x64&#x2F;electronic-wechat &#x2F;usr&#x2F;bin&#x2F;wechat</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>So now we just need to press ** ALT+F2 ** and enter wechat command to launch the WeChat client on Linux.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重装系统总结&quot;&gt;&lt;a href=&quot;#重装系统总结&quot; class=&quot;headerlink&quot; title=&quot;重装系统总结&quot;&gt;&lt;/a&gt;重装系统总结&lt;/h2&gt;&lt;h3 id=&quot;1-备份系统所在磁盘：&quot;&gt;&lt;a href=&quot;#1-备份系统所在磁盘：&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Linux" scheme="http://haijiaogao.github.io/blogs/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://haijiaogao.github.io/blogs/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://haijiaogao.github.io/blogs/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry 上手笔记</title>
    <link href="http://haijiaogao.github.io/blogs/2020/07/16/blog/techonology/raspberry/"/>
    <id>http://haijiaogao.github.io/blogs/2020/07/16/blog/techonology/raspberry/</id>
    <published>2020-07-16T08:27:38.000Z</published>
    <updated>2020-08-07T10:02:38.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>准备刷机用的东西包括（必备）：</p><ol><li><p>16Gtf卡一个加读卡器（<code>U盘不行，按说应该也可以，但是步骤繁琐，没有继续折腾</code>）</p></li><li><p>一根typeC数据线用于刷机</p></li><li><p>下载刷机包，由于同事手里有先前下载好的包和刷机工具，所以我省去了这一步。具体我刷的是buster的树莓派简化版。</p><blockquote><p>下载地址为：</p></blockquote></li></ol><ul><li>刷机工具<a href="https://www.balena.io/etcher/">etcher</a>：<code>https://www.balena.io/etcher/</code></li><li>树莓派镜像：<code>https://www.raspberrypi.org/downloads/raspbian/</code></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>(以下都狠简单，在网上一搜一大堆，只是个人记录用)</p><h3 id="1-（废话，有空删掉）"><a href="#1-（废话，有空删掉）" class="headerlink" title="1. （废话，有空删掉）"></a>1. （废话，有空删掉）</h3><p>购买树莓派，本人在转转上买了二手树莓派4b一个，200块。</p><h3 id="2-使用刷机工具制作系统刷到tf卡上。"><a href="#2-使用刷机工具制作系统刷到tf卡上。" class="headerlink" title="2. 使用刷机工具制作系统刷到tf卡上。"></a>2. 使用刷机工具制作系统刷到tf卡上。</h3><p>步骤参考：<code>https://shumeipai.nxez.com/2019/04/17/https://www.fing.com/products/fing-appwrite-pi-sd-card-image-using-etcher-on-windows-linux-mac.html</code></p><h3 id="3-树莓派首次联网，这里需要注意树莓派4b是带无线网卡的，可以直接先在tf卡制作好的系统中配置好无线ap信息。"><a href="#3-树莓派首次联网，这里需要注意树莓派4b是带无线网卡的，可以直接先在tf卡制作好的系统中配置好无线ap信息。" class="headerlink" title="3. 树莓派首次联网，这里需要注意树莓派4b是带无线网卡的，可以直接先在tf卡制作好的系统中配置好无线ap信息。"></a>3. 树莓派首次联网，这里需要注意树莓派4b是带无线网卡的，可以直接先在tf卡制作好的系统中配置好无线ap信息。</h3><p>步骤参考：<code>https://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html</code></p><h3 id="4-把tf卡安装到树莓派上，开机。"><a href="#4-把tf卡安装到树莓派上，开机。" class="headerlink" title="4. 把tf卡安装到树莓派上，开机。"></a>4. 把tf卡安装到树莓派上，开机。</h3><blockquote><p>首次启动<br>测试树莓派是否正常启动并且正常联网的方法：</p></blockquote><ol><li>通过串口查看，或者连接显示设备</li><li>都没有的话，只能过一会儿可以试试ssh raspberrypi.local 是否能连上。</li><li>或者是通过路由器或者是<a href="https://www.fing.com/products/fing-app">fing</a>工具查看局域网中所有设备，如果说有名字叫Raspberry相关的，应该就是树莓派.(我是这样搞的)</li></ol><h3 id="5-必备应用安装"><a href="#5-必备应用安装" class="headerlink" title="5. 必备应用安装"></a>5. 必备应用安装</h3><h4 id="配置apt国内源"><a href="#配置apt国内源" class="headerlink" title="配置apt国内源"></a>配置apt国内源</h4><p> 编辑/etc/apt/sources.listw文件 <code>sudo nano /etc/apt/sources.list</code> ,把原来的内容注释掉，增加国内源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br></pre></td></tr></table></figure><p>按 ctrl-o 保存，按 ctrl-x 关闭。</p><p>同样的方法，把 /etc/apt/sources.list.d/raspi.list 文件也替换成下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure><p>修改完后，在命令行执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><p>由于buster-lit版本并没有安装vim，使用vi的时候非常不方便，如果习惯使用vi 编辑文件的话建议装上vim：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim </span><br></pre></td></tr></table></figure><h3 id="6-配置vnc-server"><a href="#6-配置vnc-server" class="headerlink" title="6. 配置vnc server"></a>6. 配置vnc server</h3><p>参考树莓派实验室：<code>https://shumeipai.nxez.com/2018/08/31/raspberry-pi-vnc-viewer-configuration-tutorial.html</code></p><h3 id="7-我遇到的一些傻问题"><a href="#7-我遇到的一些傻问题" class="headerlink" title="7. 我遇到的一些傻问题"></a>7. 我遇到的一些傻问题</h3><ul><li><p>a. 没看教程，尝试自己安装vnc server<br>结果，当然失败了，系统自带的就行</p></li><li><p>b.使用其他客户端尝试登陆上去<br>,树莓派4b自带的是<a href="https://www.realvnc.com/en/connect/download/viewer/">RealVNC</a><br>如果连接的话，需要单独下载客户端，我试过mac上面的dump desktop连不上去。提示错误：</p></li></ul><p><code>no configured security type is supported by 3.3 vnc viewer raspberry pi</code></p><ul><li>c. 下了RealVNC Viewer,但是傻憨憨的不知道默认用户名密码！查了半天才找到</li></ul><p>默认账号：<code>pi</code><br>默认密码：<code>raspberry</code></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不要小瞧小小的树莓派，原本我以为都是linux的，和ubuntu的差不多，但是实际上还是有很多需要注意的地方，如果提前先在网上看看，可以避免很多低级错误！切记！</p><h2 id="学习链接："><a href="#学习链接：" class="headerlink" title="学习链接："></a>学习链接：</h2><p>官网：<code>https://www.raspberrypi.org/</code><br>树莓派实验室：<code>https://shumeipai.nxez.com/</code><br>树莓派技术圈：<code>https://raspberrypi.tech/</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;准备刷机用的东西包括（必备）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;16Gtf卡一个加读卡器（&lt;code&gt;U盘不行，按说应该也可以，但是步骤繁琐</summary>
      
    
    
    
    <category term="Raspberry" scheme="http://haijiaogao.github.io/blogs/categories/Raspberry/"/>
    
    
  </entry>
  
  <entry>
    <title>使用hexo.js + travis.cli + Next.js主题在Github上搭建个人博客</title>
    <link href="http://haijiaogao.github.io/blogs/2020/07/14/blog/techonology/how-to-create-blog/"/>
    <id>http://haijiaogao.github.io/blogs/2020/07/14/blog/techonology/how-to-create-blog/</id>
    <published>2020-07-14T07:08:42.000Z</published>
    <updated>2020-08-07T10:02:38.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、动因"><a href="#一、动因" class="headerlink" title="一、动因"></a>一、动因</h2><p>笔者最近很闲，于是把很多之前在ToDoList上的计划提上了日程，其中就包含搭建自己的个人blog。又由于笔者算是互联网从业者，于是选择在自己的github搭建，而不是直接写在其他的技术blog上面。</p><h2 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h2><ol><li>首先，github账户一定要基本具备</li><li>考察网上成型方案，当然笔者在此走了许多的弯路，下面会详细记录笔者遇到的若干小白问题。</li><li>开动</li></ol><h2 id="三、方案1-基于Jekyll"><a href="#三、方案1-基于Jekyll" class="headerlink" title="三、方案1-基于Jekyll"></a>三、方案1-基于Jekyll</h2><p>基于Jekyll的方案是Github Page直接支持的方案，该方案简单，步骤少，配置少，基于markdown。但是我最终没有采用该方式。主要的原因是因为主题少，插件少，而且在本地运行的时候，需要安装ruby相关工具，ruby并不在我的技术栈，以及我想了解的技术栈之内，故放弃之。</p><p>Jekyll方案指南:<a href="https://pages.github.com/">Jekyll方案指南</a></p><p>其中有个细节点需要注意：<br>在新建repo库的时候，如果说想以username.github.io/进行访问，则库名必须为username.github.io。</p><p>示意：<img src="images/create-repo.png" alt="repo库必须为`username.github.io`"></p><h2 id="四、方案2-基于node-js的hexo-js-Next-js主题方案"><a href="#四、方案2-基于node-js的hexo-js-Next-js主题方案" class="headerlink" title="四、方案2-基于node.js的hexo.js+Next.js主题方案"></a>四、方案2-基于node.js的hexo.js+Next.js主题方案</h2><p>方案一很好，入门方便，但是我在preview的时候总是对主题不太满意，之前看到过一些别人的blog的风格非常的简洁，搜了搜，是基于Next.js的，所以为了提高难度，改为用node.js+hexo.js+Next.js的方案二进行博客的搭建。</p><p>网上一搜教程一堆，正好发现了github 目前增加了自动化构建相关的内容，一并练练手，反正闲着也是闲着。</p><p>废话有点多，具体步骤如下：</p><h4 id="1-安装node：我的mac很久以前安装过node-js大概是3年前的旧事了，所以node版本很老，大概是6-x的版本，查看了一下官网上的稳定版都已经更新到了12-x而且，hexo的新版最低要求也是8-x的，所以我是从更新node开始的。"><a href="#1-安装node：我的mac很久以前安装过node-js大概是3年前的旧事了，所以node版本很老，大概是6-x的版本，查看了一下官网上的稳定版都已经更新到了12-x而且，hexo的新版最低要求也是8-x的，所以我是从更新node开始的。" class="headerlink" title="1. 安装node：我的mac很久以前安装过node.js大概是3年前的旧事了，所以node版本很老，大概是6.x的版本，查看了一下官网上的稳定版都已经更新到了12.x而且，hexo的新版最低要求也是8.x的，所以我是从更新node开始的。"></a>1. 安装node：我的mac很久以前安装过node.js大概是3年前的旧事了，所以node版本很老，大概是6.x的版本，查看了一下官网上的稳定版都已经更新到了12.x而且，hexo的新版最低要求也是8.x的，所以我是从更新node开始的。</h4><blockquote><p>安装（Mac os可以直接使用brew命令，其他平台参考node.js官网）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><blockquote><p>更新(我没有使用brew，而是通过一个nvm脚本)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br><span class="line"></span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line">nvm install 12.18.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-安装hexo-cli"><a href="#2-安装hexo-cli" class="headerlink" title="2. 安装hexo-cli"></a>2. 安装hexo-cli</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="3-使用hexo初始化一个项目-我的叫blog"><a href="#3-使用hexo初始化一个项目-我的叫blog" class="headerlink" title="3. 使用hexo初始化一个项目,我的叫blog"></a>3. 使用hexo初始化一个项目,我的叫blog</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>接下来就可以用hexo相关的命令进行blog的配置和博客书写啦</p><h4 id="4-使用travis-cli实现github-repo库的自动编译"><a href="#4-使用travis-cli实现github-repo库的自动编译" class="headerlink" title="4. 使用travis-cli实现github repo库的自动编译"></a>4. 使用travis-cli实现github repo库的自动编译</h4><blockquote><p>需要注意的一点，使用travis-cli后会自动把主分支（假设hexo项目是push到主分支）上的hexo项目编译生成的public目录内容push到一个新分支，默认叫gh-pages。但是如果按照方案一的repo name命名后，github pages默认只能使用master分支的内容。so，此处repo库一定不要命名成 <del>username.github.io</del>，以笔者为例，笔者命名为<code>blogs</code></p></blockquote><blockquote><p><a href="https://hexo.io/zh-cn/docs/github-pages">travis</a> 配置githubpages指南,参考链接，需要涉及到github的Token获取，客户端blog项目中增加travis.yml配置等内容，此处略过不提</p></blockquote><p>配置travis的过程算是顺利，但是，当我把项目代码push 到master分支后，我发现travis编译失败了，而且一直是失败在了yarn下载package配置的地方，经过网上高人指点，我在项目中删除掉了<code>package-lock.json</code>以及<code>yarn-lock.json</code>两个配置文件，并且修改了<code>travis.yml</code>配置，最终终于编译成功^ ^</p><p>我的travis.yml如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">before-install:  # 我改了这里</span><br><span class="line">  - npm install -g hexo-cli # 我改了这里</span><br><span class="line">install: # 我改了这里</span><br><span class="line">  - npm install  # 我改了这里</span><br><span class="line">  - npm install hexo-deployer-git --save  # 我改了这里</span><br><span class="line">script:</span><br><span class="line">  - hexo clean # 我改了这里</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://github.com/haijiaogao/blogs/commit/6586f08a04dc01647bc6be4614d03e22d847356f">Github提交</a></p><h4 id="5-使用hexo-deployer-git-实现私有库编译"><a href="#5-使用hexo-deployer-git-实现私有库编译" class="headerlink" title="5.使用hexo-deployer-git 实现私有库编译"></a>5.使用hexo-deployer-git 实现私有库编译</h4><ul><li>安装<a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li>配置_config.yml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; # https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><ul><li>胜利只差一步执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy -m &quot;deploy message &quot;</span><br></pre></td></tr></table></figure><h4 id="6-Next-js主题安装以及配置"><a href="#6-Next-js主题安装以及配置" class="headerlink" title="6. Next.js主题安装以及配置"></a>6. <a href="https://github.com/iissnan/hexo-theme-next">Next.js</a>主题安装以及配置</h4><p>该主题非常的简洁，而且包含很多插件，有兴趣可以鼓捣鼓捣，应该还挺有意思<br>具体设置步骤在github中写的非常详尽，此处不再复述。</p><p>说一下我遇到的问题吧，在使用了next主题之后，发现顶部的home和archives以及categories几个跳转菜单，都跳不过去，本地调试不行，放在github中也不行，后面总是有几个奇怪的字符串，然后报404的错误。</p><ul><li><strong>Round 1</strong>:</li></ul><p>我开始以为是favico的问题，因为在chrome的调试窗口下，会报这个图标404，一顿操作猛如虎之后，图标确实陪好了，可这几个链接，还是不行</p><ul><li><strong>Round 2</strong></li></ul><p>我又猜测是我的_config.yml中配置的permlink的问题。好吧，该猜测实在是毫无根据。所以我又失败了</p><ul><li><strong>Round 3</strong></li></ul><p>莫非是主题的问题？我决定换回landscape主题试一下！奇迹般的可以跳过去！！<br>所以，Next主题到底哪里出了问题呢，我在github中搜到了相关的<a href="https://github.com/theme-next/hexo-theme-next/issues/2">issue</a>，最后，我发现了问题的根源</p><blockquote><p>以下内容来自于<code>projectRoot/source/_data/next.yml</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>万恶之源就在于<code>*home: / ~~|| home~~* </code> || home也生成到了路径里面！！</p><blockquote><p>以下是正确示范</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F;</span><br><span class="line">  archives: &#x2F;archives&#x2F;</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>其他的细枝末节就不说啦，我的小站总算是完成了万里长征的第一步。</p><h2 id="Refreence："><a href="#Refreence：" class="headerlink" title="Refreence："></a>Refreence：</h2><p>Hexo:<br><a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a><br><a href="https://hexo.io/zh-cn/docs/permalinks">https://hexo.io/zh-cn/docs/permalinks</a></p><p>Travis:<br><a href="https://docs.travis-ci.com/">https://docs.travis-ci.com/</a></p><p>Next.js:<br><a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><h2 id="完！"><a href="#完！" class="headerlink" title="完！"></a>完！</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、动因&quot;&gt;&lt;a href=&quot;#一、动因&quot; class=&quot;headerlink&quot; title=&quot;一、动因&quot;&gt;&lt;/a&gt;一、动因&lt;/h2&gt;&lt;p&gt;笔者最近很闲，于是把很多之前在ToDoList上的计划提上了日程，其中就包含搭建自己的个人blog。又由于笔者算是互联网从业</summary>
      
    
    
    
    <category term="Techonology" scheme="http://haijiaogao.github.io/blogs/categories/Techonology/"/>
    
    <category term="Node.js" scheme="http://haijiaogao.github.io/blogs/categories/Techonology/Node-js/"/>
    
    
    <category term="Node.js" scheme="http://haijiaogao.github.io/blogs/tags/Node-js/"/>
    
    <category term="hexo.js" scheme="http://haijiaogao.github.io/blogs/tags/hexo-js/"/>
    
    <category term="travis.cli" scheme="http://haijiaogao.github.io/blogs/tags/travis-cli/"/>
    
    <category term="Next.js" scheme="http://haijiaogao.github.io/blogs/tags/Next-js/"/>
    
    <category term="Github" scheme="http://haijiaogao.github.io/blogs/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://haijiaogao.github.io/blogs/2020/07/14/about/me/"/>
    <id>http://haijiaogao.github.io/blogs/2020/07/14/about/me/</id>
    <published>2020-07-14T06:53:13.000Z</published>
    <updated>2020-08-07T10:02:38.429Z</updated>
    
    <content type="html"><![CDATA[<p>大龄已婚已育Android开发程序媛一枚，优点是已婚已育，有个儿子😂</p><p>好吧，虽然如此，还是想更多尝试一下新的东西，还好年龄以及工龄没有阻碍我的好奇心。</p><p>That‘s me！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大龄已婚已育Android开发程序媛一枚，优点是已婚已育，有个儿子😂&lt;/p&gt;
&lt;p&gt;好吧，虽然如此，还是想更多尝试一下新的东西，还好年龄以及工龄没有阻碍我的好奇心。&lt;/p&gt;
&lt;p&gt;That‘s me！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂" scheme="http://haijiaogao.github.io/blogs/categories/%E6%9D%82/"/>
    
    
  </entry>
  
</feed>
